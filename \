const std = @import("std");
const token = @import("tokens.zig");
const ast = @import("ast.zig");
const utils = @import("utils.zig");

const Token = token.Token;
const TokenType = token.TokenType;

const Precedence = ast.Precedence;
const Expression = ast.Expression;
const BinaryOperator = ast.BinaryOperator;
const UnaryOperator = ast.UnaryOperator;

pub const Parser = struct {
    tokens: []const Token,
    alloc: std.mem.Allocator,
    current: usize = 0,
    line: usize = 1,

    pub fn init(tokens: []const Token, alloc: std.mem.Allocator) Parser {
        return Parser{ .tokens = tokens, .alloc = alloc };
    }

    pub fn deinit(self: *Parser) void {
        _ = self;
    }

    fn make_expression_pointer(self: *Parser, expr: Expression) !*Expression {
        const ptr = try self.alloc.create(Expression);
        ptr.* = expr;
        return ptr;
    }

    pub fn parse(self: *Parser) !std.ArrayList(*Expression) {
        var statements = std.ArrayList(*Expression).init(self.alloc);
        errdefer statements.deinit();

        while (self.current_token().type != .Eof) {
            const expr = try self.parse_expression(.Lowest);
            try statements.append(expr);
        }

        return statements;
    }

    fn parse_expression(self: *Parser, prec: Precedence) anyerror!*Expression {
        var expr = switch (self.current_token().type) {
            .IntLiteral => try self.parse_int_literal(),
            .LParen => try self.parse_group_expression(),
            .True, .False => try self.parse_bool_literal(),
            .Plus => try self.parse_unary_expression(.Plus),
            .Minus => try self.parse_unary_expression(.Minus),
            .Bang => try self.parse_unary_expression(.Not),
            else => return error.NoParseFunctionForTokenType,
        };

        while (self.current_prec() > @intFromEnum(prec)) {
            // we probably can abstrct this away into a single function call
            switch (self.current_token().type) {
                .IntLiteral => return error.ConsecutiveInts, // TODO: this condition is actually never reached, fix this bug! (potentially replace > with >= but idk)
                .Plus => expr = try self.parse_binary_expression(expr, .Plus, .Sum),
                .Minus => expr = try self.parse_binary_expression(expr, .Minus, .Sum),

                .Star => expr = try self.parse_binary_expression(expr, .Multiply, .Product),
                .Slash => expr = try self.parse_binary_expression(expr, .Divide, .Product),

                .DoubleEqual => expr = try self.parse_binary_expression(expr, .Equal, .Equality),
                .NotEqual => expr = try self.parse_binary_expression(expr, .NotEqual, .Equality),

                .LessThan => expr = try self.parse_binary_expression(expr, .LessThan, .Comparison),
                .GreaterThan => expr = try self.parse_binary_expression(expr, .GreaterThan, .Comparison),
                .LessThanOrEqual => expr = try self.parse_binary_expression(expr, .LessThanOrEqual, .Comparison),
                .GreaterThanOrEqual => expr = try self.parse_binary_expression(expr, .GreaterThanOrEqual, .Comparison),

                .DoubleAmpersand => expr = try self.parse_binary_expression(expr, .LogicalAnd, .Logical),
                .DoublePipe => expr = try self.parse_binary_expression(expr, .LogicalOr, .Logical),

                .Caret => expr = try self.parse_binary_expression(expr, .Exponent, .Exponent),
                .Eof => return expr,
                else => return error.InvalidOperator,
            }
        }

        return expr;
    }

    fn parse_unary_expression(self: *Parser, op: UnaryOperator) !*Expression {
        self.advance();
        const rhs = try self.parse_expression(.Prefix);

        return self.make_expression_pointer(.{ .Unary = .{
            .operator = op,
            .right = rhs,
        } });
    }

    fn parse_group_expression(self: *Parser) !*Expression {
        self.advance(); // consume '('
        const expr = try self.parse_expression(.Lowest);
        if (self.current_token().type != .RParen) {
            return error.ExpectedRParen;
        }
        self.advance(); // consume ')'
        return expr;
    }

    fn parse_binary_expression(self: *Parser, lhs: *Expression, op: BinaryOperator, prec: Precedence) !*Expression {
        self.advance();

        // TODO: this is a hack, we should change this function's implementation. Maybe add a `allow_prefix` parameter?
        if (self.current_token().type == .Plus or self.current_token().type == .Minus or self.current_token().type == .Bang) {
            return error.UnexpectedUnaryOperator;
        }
        const rhs = try self.parse_expression(prec);

        return self.make_expression_pointer(.{ .Binary = .{
            .left = lhs,
            .operator = op,
            .right = rhs,
        } });
    }

    fn expect_token(self: *Parser, token_type: TokenType) !void {
        if (self.current_token().type != token_type) {
            return error.UnexpectedTokenType;
        }
        self.advance();
    }

    fn expect_int(self: *Parser) !i64 {
        switch (self.current_token().type) {
            .IntLiteral => |int| {
                self.advance();
                return int;
            },
            else => return error.ExpectedInt,
        }
    }

    fn parse_bool_literal(self: *Parser) !*Expression {
        switch (self.current_token().type) {
            .True => {
                try self.expect_token(.True);
                return try self.make_expression_pointer(.{ .BoolLiteral = true });
            },
            .False => {
                try self.expect_token(.False);
                return try self.make_expression_pointer(.{ .BoolLiteral = false });
            },
            else => return error.ExpectedBool,
        }
    }

    fn parse_int_literal(self: *Parser) !*Expression {
        return try self.make_expression_pointer(.{ .IntLiteral = try self.expect_int() });
    }

    fn advance(self: *Parser) void {
        self.current += 1;
    }

    fn current_token(self: *Parser) Token {
        if (self.current >= self.tokens.len) {
            return Token{ .type = .Eof, .pos = token.Span{ .start = 0, .size = 0 }, .line = self.line };
        }
        return self.tokens[self.current];
    }

    fn get_token_prec(_: *Parser, token_type: TokenType) Precedence {
        return switch (token_type) {
            .DoubleAmpersand => .Logical,
            .DoublePipe => .Logical,

            .DoubleEqual => .Equality,
            .NotEqual => .Equality,

            .LessThan => .Comparison,
            .GreaterThan => .Comparison,
            .LessThanOrEqual => .Comparison,
            .GreaterThanOrEqual => .Comparison,

            .Plus => .Sum,
            .Minus => .Sum,

            .Star => .Product,
            .Slash => .Product,

            .Caret => .Exponent,

            .LParen => .Group,

            else => Precedence.Lowest,
        };
    }

    fn current_prec(self: *Parser) u8 {
        return @intFromEnum(self.get_token_prec(self.current_token().type));
    }
};
